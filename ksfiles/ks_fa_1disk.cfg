# Generated by Anaconda 42.27.12
# Generated by pykickstart v3.62
#version=DEVEL

%pre --interpreter=/usr/bin/python3 --erroronfail
import json
import os
import subprocess
import sys
import time

diskpath = "{{diskpath}}"
rootsizemib = {{rootsizemib}}
root_end_mib = 2048 + 2048 + rootsizemib # efi size + boot size + rootsizemib
wipe_parts = [ 1, 2, 3 ]

# Persist the disk identifier without newline
with open('/tmp/disk-id', 'w') as f:
    f.write(diskpath)

# Generate partitions.ks Kickstart fragment
partitions_ks = f"""
ignoredisk --only-use={diskpath}
part /boot/efi --fstype="efi" --onpart={diskpath}-part1 --fsoptions="umask=0077,shortname=winnt"
part btrfs.2 --fstype="btrfs" --onpart={diskpath}-part2
part btrfs.3 --fstype="btrfs" --onpart={diskpath}-part3 --encrypted --luks-version=luks2

btrfs /boot --label=fedora_boot --data=single btrfs.2
btrfs none --label=fedora_fedora --data=single btrfs.3

btrfs / --subvol --name=root fedora_fedora
btrfs /var --subvol --name=var fedora_fedora
btrfs /home --subvol --name=home fedora_fedora
"""
with open('/tmp/partitions.ks', 'w') as f:
    f.write(partitions_ks)

# Debug output for partitions.ks
print("DEBUG: Generated /tmp/partitions.ks:")
print(partitions_ks)

# Gather disk info via lsblk
lsblk_cmd = [
    "lsblk", "--bytes", "-Jo",
    ("DISK-SEQ,NAME,KNAME,PKNAME,PATH,ID-LINK,SCHED,SIZE,START,PTTYPE,"
     "TYPE,PARTN,PARTTYPE,PARTTYPENAME,PARTFLAGS,PARTLABEL,FSTYPE,"
     "FSROOTS,MOUNTPOINTS"),
    diskpath
]
print(f"DEBUG: Running lsblk: {' '.join(lsblk_cmd)}")
try:
    raw = subprocess.check_output(lsblk_cmd,
                                  stderr=subprocess.PIPE,
                                  text=True)
    print("DEBUG: Raw lsblk output:")
    print(raw)
except subprocess.CalledProcessError as err:
    print(f"ERROR: lsblk failed: {err.stderr}", file=sys.stderr)
    sys.exit(1)

# Parse JSON
print("DEBUG: Parsed JSON:")
try:
    data = json.loads(raw)
    print(json.dumps(data, indent=2))
except json.JSONDecodeError as err:
    print(f"ERROR: Failed to parse JSON: {err}", file=sys.stderr)
    sys.exit(1)

# Check if blockdevice
block_devices = data.get("blockdevices")
if not block_devices:
    print(f"ERROR: No blockdevices entry for {diskpath}", file=sys.stderr)
    sys.exit(1)
if len(block_devices) != 1:
    print(f"ERROR: Expected exactly one blockdevice entry for {diskpath}, found {len(block_devices)}", file=sys.stderr)
    sys.exit(1)

print(f"INFO: Found blockdevices entry for {diskpath}")

# Check if disk
disk_info = block_devices[0]
disk_id_link = disk_info.get('id-link')
disk_type = disk_info.get("type")
if disk_type != "disk":
    print(f"ERROR: {diskpath} is type={disk_type}, not a disk",
          file=sys.stderr)
    sys.exit(1)

print(f"INFO: {diskpath} is confirmed as a whole disk.")

should_partition = False

# Check for existing partition table
disk_pttype = disk_info.get("pttype")
if disk_pttype:
    print(f"INFO: {diskpath} has existing partition table type '{disk_pttype}'; skipping partitioning")
    should_partition = False
else:
  # No partition table
  print(f"INFO: {diskpath} has no partition table, partition table type is '{disk_pttype}'.")


  # Further check for a filesystem directly on the disk
  disk_fstype = disk_info.get("fstype")
  if disk_fstype:
      print(f"INFO: {diskpath} has existing filesystem '{disk_fstype}'; skipping partitioning")
      should_partition = False
  else:
      print(f"INFO: No filesystem detected on {diskpath}")
      # This is the only condition where we do partitioning - no partition table and no FS
      should_partition = True

# Furhter check for existing partitions - should only be True when disk has partition table
disk_parts = disk_info.get("children")
if  disk_parts:
    should_partition = False

    # If GPT exists or partitions exist, wipe partitions defined in wipe_parts
    if disk_pttype in [ 'gpt' ] and disk_parts:
        for p in disk_parts:
            part_id_link = p.get("id-link")
            part_path = f"/dev/disk/by-id/{part_id_link}"
            print(f"INFO: {diskpath} has existing partition: {part_path}")
            if part_id_link in [f"{disk_id_link}-part{i}" for i in wipe_parts]:
                wipe_cmd = ["wipefs","--force","--all", part_path]
                print(f"DEBUG: Running wipe: {' '.join(wipe_cmd)}")
                subprocess.check_call(wipe_cmd)
        print(f"INFO: signatures wiped on parts {wipe_parts} wiped.")

    partprobe_cmd = ["partprobe", diskpath]
    print(f"DEBUG: Running partprobe: {' '.join(partprobe_cmd)}")
    subprocess.check_call(partprobe_cmd)
else:
    print(f"INFO: {diskpath} has no partitions.")

if should_partition:
    # Disk is valid and empty â€“ now partition it
    print(f"INFO: Partitioning {diskpath}")
    parted_cmd = [
        "parted", "--script", diskpath,
        "unit", "MiB",
        "mklabel", "gpt",
        "mkpart", "primary", "1", "2048",
        "mkpart", "primary", "2048", "4096",
        "mkpart", "primary", "4096", str(root_end_mib),
        "set", "1", "boot", "on",
        "set", "1", "esp", "on",
        "set", "2", "bls_boot", "on",
        "name", "1", "'EFI System Partition'",
        "name", "2", "''",
        "name", "3", "''"
    ]
    print(f"DEBUG: Running parted: {' '.join(parted_cmd)}")
    subprocess.check_call(parted_cmd)
else:
    print("INFO: Partitioning skipped.")

# Wait for udev to settle
for ucmd in ['trigger', 'settle']
    subprocess.check_call(["udevadm", ucmd])
    time.sleep(5)

# Show free space after partitioning
print("INFO: Current partition layout (free space):")
subprocess.check_call([
    "parted", "--script", diskpath,
    "unit", "MiB", "print", "free"
])

%end

%include /tmp/partitions.ks

# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'
# System language
lang en_US.UTF-8

# Firewall configuration
firewall --use-system-defaults

# OSTree setup
ostreesetup --osname="fedora" --remote="fedora" --url="file:///ostree/repo" --ref="{{version}}" --nogpg

# System timezone
timezone Europe/Vienna --utc

#Root password
rootpw --lock
user --groups=wheel --name={{user}} --password={{userpwhash}} --iscrypted --uid=1000 --gid=1000

# Run the Setup Agent on first boot
firstboot --disable

#FIXME disable location services configured in gnome-firstboot

%post --erroronfail --nochroot

DISK=$(cat /tmp/disk-id)

parted --script "${DISK}" set 2 bls_boot on
udevadm trigger && sleep 5 && udevadm settle && sleep 5

mkdir -p /mnt/sysroot/var/log/anaconda
cp /tmp/partitions.ks /mnt/sysroot/var/log/anaconda/

%end

%post --erroronfail
cp /etc/skel/.bash* /root

chage -d 0 hoo || true

systemctl enable sshd.service



%end
