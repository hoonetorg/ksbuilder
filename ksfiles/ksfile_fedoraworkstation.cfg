# Generated by Anaconda 43.44

%pre --interpreter=/usr/bin/python3 --erroronfail
import logging

import os
import sys
import subprocess
import shlex
from typing import Any

import json
import time

import re


def subprocess_run_wrapper(
    cmd: str, dryrun: bool = False, **kwargs
) -> subprocess.CompletedProcess | None:
    if kwargs.get("shell"):
        wcmd = cmd
    else:
        wcmd = shlex.split(cmd)

    if dryrun:
        logging.info(f"[DRYRUN] {cmd}")
        return None

    logging.info(f"[EXECUTING] {cmd}")
    return subprocess.run(wcmd, **kwargs)


def write_ks_snippets(
    diskpath: str, disklayout: dict, btrfsbootlabel: str, btrfsrootlabel: str
):
    esp_number = disklayout["esp"]["number"]
    boot_number = disklayout["boot"]["number"]
    root_number = disklayout["root"]["number"]

    efi_fstype_opt = '--fstype="efi"' if disklayout["esp"]["wipe"] else "              "
    efi_noformat_opt = "--noformat" if not disklayout["esp"]["wipe"] else ""

    # Persist the disk identifier without newline
    with open("/tmp/disk-id", "w") as f:
        f.write(str(diskpath))

    with open("/tmp/boot-number", "w") as f:
        f.write(str(boot_number))

    # Generate partitions.ks Kickstart fragment
    partitions_ks = f"""
    ignoredisk --only-use={diskpath}
    part /boot/efi {efi_fstype_opt} --onpart={diskpath}-part{esp_number} {efi_noformat_opt} --fsoptions="umask=0077,shortname=winnt"
    part btrfs.{boot_number} --fstype="btrfs" --onpart={diskpath}-part{boot_number}
    part btrfs.{root_number} --fstype="btrfs" --onpart={diskpath}-part{root_number} --encrypted --luks-version=luks2
    
    btrfs none --label={btrfsbootlabel} --data=single btrfs.{boot_number}
    btrfs none --label={btrfsrootlabel} --data=single btrfs.{root_number} 
    
    btrfs / --subvol --name=root {btrfsrootlabel}
    btrfs /boot --subvol --name=boot {btrfsbootlabel}
    btrfs /home --subvol --name=home {btrfsrootlabel}
    """
    with open("/tmp/partitions.ks", "w") as f:
        f.write(partitions_ks)

    # Debug output for partitions.ks
    logging.info(f"Generated /tmp/partitions.ks:\n{partitions_ks}")


def get_diskinfo(diskpath: str, dryrun: bool = False) -> Any:
    # Gather disk info via lsblk
    try:
        result = subprocess_run_wrapper(
            cmd=(
                "lsblk --bytes -Jo "
                "DISK-SEQ,NAME,KNAME,PKNAME,PATH,ID-LINK,SCHED,SIZE,START,PTTYPE,"
                "TYPE,PARTN,PARTTYPE,PARTTYPENAME,PARTFLAGS,PARTLABEL,FSTYPE,"
                "FSROOTS,MOUNTPOINTS "
                f"{shlex.quote(diskpath)}"
            ),
            dryrun=dryrun,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            check=True,
        )

        if dryrun or result is None:
            return None

        raw = result.stdout
        logging.info(f"Raw lsblk output:\n{raw}")
    except subprocess.CalledProcessError as err:
        logging.error(f"lsblk failed: {err.stderr}")
        sys.exit(1)

    # Parse JSON
    logging.info("Parsed JSON:")
    try:
        data = json.loads(raw)
        logging.info(f"JSON loads lsblk output:\n{json.dumps(data, indent=2)}")
    except json.JSONDecodeError as err:
        logging.error(f"Failed to parse JSON: {err}")
        sys.exit(1)

    # Check if blockdevice
    blockdevices = data.get("blockdevices")

    if not blockdevices:
        logging.error(f"No blockdevices entry for {diskpath}")
        return blockdevices
    if len(blockdevices) != 1:
        logging.error(
            f"Expected exactly one blockdevice entry for {diskpath}, found {len(blockdevices)}"
        )
        return False

    logging.info(f"Found blockdevices entry for {diskpath}")
    return blockdevices[0]


def check_should_partition(diskpath: str, diskinfo: dict) -> bool:

    # Check if disk
    disktype = diskinfo.get("type")
    if disktype != "disk":
        logging.error(f"{diskpath} is type={disktype}, not a disk")
        sys.exit(1)

    logging.info(f"{diskpath} is confirmed as a whole disk.")

    should_partition = False

    # Check for existing partition table
    diskpttype = diskinfo.get("pttype")
    if diskpttype:
        logging.info(
            f"{diskpath} has existing partition table type '{diskpttype}'; skipping partitioning"
        )
        should_partition = False
    else:
        # No partition table
        logging.info(
            f"{diskpath} has no partition table, partition table type is '{diskpttype}'."
        )

        # Further check for a filesystem directly on the disk
        disk_fstype = diskinfo.get("fstype")
        if disk_fstype:
            logging.info(
                f"{diskpath} has existing filesystem '{disk_fstype}'; skipping partitioning"
            )
            should_partition = False
        else:
            logging.info(f"No filesystem detected on {diskpath}")
            # This is the only condition where we do partitioning - no partition table and no FS
            should_partition = True

    # Further check for existing partitions - should only be True when disk has partition table
    if diskinfo.get("children"):
        logging.info(
            f"{diskpath} has probably existing partitions; skipping partitioning"
        )
        should_partition = False
    else:
        logging.info(f"{diskpath} has no partitions.")

    return should_partition


def do_device_settle(dryrun: bool = False):
    # Wait for udev to settle
    for ucmd in ["trigger", "settle"]:
        subprocess_run_wrapper(cmd=f"udevadm {shlex.quote(ucmd)}", dryrun=dryrun)
        time.sleep(5)


def do_wipeparts(
    diskpath: str, diskinfo: dict, disklayout: dict, dryrun: bool = False
) -> bool:

    wipeparts = sorted(
        part["number"] for part in disklayout.values() if part.get("wipe")
    )

    # diskid_link = diskinfo.get("id-link")
    diskparts = diskinfo.get("children")
    diskpttype = diskinfo.get("pttype")
    if diskparts:
        # If GPT exists or partitions exist, wipe partitions defined in wipeparts
        if diskpttype in ["gpt"] and diskparts:
            for p in diskparts:
                partid_link = p.get("id-link")
                partnumber = p.get("partno") or p.get("partn")
                partpath = f"/dev/disk/by-id/{partid_link}"
                logging.info(f"{diskpath} has existing partition: {partpath}")
                if partnumber and (int(partnumber) in wipeparts):
                    subprocess_run_wrapper(
                        cmd=f"wipefs --force --all {shlex.quote(partpath)}",
                        dryrun=dryrun,
                    )
            logging.info(f"signatures wiped on parts {wipeparts}.")

        subprocess_run_wrapper(cmd=f"partprobe {shlex.quote(diskpath)}", dryrun=dryrun)
        do_device_settle(dryrun=dryrun)


def do_partition(diskpath: str, disklayout: dict, dryrun: bool = False):
    # Disk is valid and empty â€“ now partition it
    esp_number = disklayout["esp"]["number"]
    boot_number = disklayout["boot"]["number"]
    root_number = disklayout["root"]["number"]

    start_mib = 1
    esp_mib = disklayout["esp"]["sizemib"]
    boot_mib = disklayout["boot"]["sizemib"]
    root_mib = disklayout["root"]["sizemib"]
    esp_end_mib = start_mib + esp_mib
    boot_end_mib = esp_end_mib + boot_mib
    root_end_mib = boot_end_mib + root_mib

    logging.info(
        f"ESP: number: {esp_number}, size(MiB): {esp_mib}, start(MiB): {start_mib}, end(MiB): {esp_end_mib}"
    )
    logging.info(
        f"boot: number: {boot_number}, size(MiB): {boot_mib}, start(MiB): {esp_end_mib}, end(MiB): {boot_end_mib}"
    )
    logging.info(
        f"root: number: {root_number}, size(MiB): {root_mib}, start(MiB): {boot_end_mib}, end(MiB): {root_end_mib}"
    )

    logging.info(f"Partitioning {diskpath}")
    subprocess_run_wrapper(
        cmd=(
            "parted --script "
            f"{shlex.quote(diskpath)} "
            "unit MiB "
            "mklabel gpt "
            f"mkpart primary {shlex.quote(str(start_mib))} {shlex.quote(str(esp_end_mib))} "
            f"mkpart primary {shlex.quote(str(esp_end_mib))} {shlex.quote(str(boot_end_mib))} "
            f"mkpart primary {shlex.quote(str(boot_end_mib))} {shlex.quote(str(root_end_mib))} "
            f"set {shlex.quote(str(esp_number))} boot on "
            f"set {shlex.quote(str(esp_number))} esp on "
            f"set {shlex.quote(str(boot_number))} bls_boot on "
            f"name {shlex.quote(str(esp_number))} {shlex.quote("'EFI System Partition'")} "
            f"name {shlex.quote(str(boot_number))} {shlex.quote("''")} "
            f"name {shlex.quote(str(root_number))} {shlex.quote("''")}"
        ),
        dryrun=dryrun,
    )

    subprocess_run_wrapper(cmd=f"partprobe {shlex.quote(diskpath)}", dryrun=dryrun)
    do_device_settle(dryrun=dryrun)

    # Show free space after partitioning
    logging.info("Current partition layout (free space):")
    subprocess_run_wrapper(
        cmd=("parted --script " f"{shlex.quote(diskpath)} " "unit MiB print free"),
        dryrun=dryrun,
    )


def do_add_partitions(
    diskpath: str, disklayout: dict, start_mib: int, dryrun: bool = False
):
    boot_number = disklayout["boot"]["number"]
    root_number = disklayout["root"]["number"]

    boot_mib = disklayout["boot"]["sizemib"]
    root_mib = disklayout["root"]["sizemib"]
    boot_end_mib = start_mib + boot_mib
    root_end_mib = boot_end_mib + root_mib

    logging.info(
        f"boot: number: {boot_number}, size(MiB): {boot_mib}, start(MiB): {start_mib}, end(MiB): {boot_end_mib}"
    )
    logging.info(
        f"root: number: {root_number}, size(MiB): {root_mib}, start(MiB): {boot_end_mib}, end(MiB): {root_end_mib}"
    )

    logging.info(f"Partitioning {diskpath}")
    subprocess_run_wrapper(
        cmd=(
            "parted --script "
            f"{shlex.quote(diskpath)} "
            "unit MiB "
            f"mkpart primary {shlex.quote(str(start_mib))} {shlex.quote(str(boot_end_mib))} "
            f"mkpart primary {shlex.quote(str(boot_end_mib))} {shlex.quote(str(root_end_mib))} "
            f"set {shlex.quote(str(boot_number))} bls_boot on "
            f"name {shlex.quote(str(boot_number))} {shlex.quote("''")} "
            f"name {shlex.quote(str(root_number))} {shlex.quote("''")}"
        ),
        dryrun=dryrun,
    )

    subprocess_run_wrapper(cmd=f"partprobe {shlex.quote(diskpath)}", dryrun=dryrun)
    do_device_settle(dryrun=dryrun)

    # Show free space after partitioning
    logging.info("Current partition layout (free space):")
    subprocess_run_wrapper(
        cmd=("parted --script " f"{shlex.quote(diskpath)} " "unit MiB print free"),
        dryrun=dryrun,
    )


def parted_is_free_row(fields: list[str]) -> bool:
    # Format: N:START:END:SIZE:FS=free
    return len(fields) == 5 and fields[4].strip().lower() == "free"


def mib_to_int(token: str) -> int:
    """
    Convert '413696MiB' or '0.02MiB' to int MiB by truncating after '.'.
    No floats used.
    """
    t = token.strip()
    if not t.endswith("MiB"):
        logging.error(f"unexpected unit (expected MiB): {token!r}")
        sys.exit(1)
    t = t[:-3]  # drop 'MiB'
    if "." in t:
        t = t.split(".", 1)[0]
    if t == "":
        return 0
    return int(t)


def read_parted_entries(diskpath: str, dryrun: bool = False) -> list[dict]:
    r = subprocess_run_wrapper(
        cmd=f"parted -m -s {shlex.quote(diskpath)} unit MiB print free",
        dryrun=dryrun,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True,
    )

    logging.info(f"Current partition layout (free space):\n{r.stdout}")

    if dryrun or r is None:
        return []

    entries = []
    for line in r.stdout.splitlines():
        line = line.strip()
        if (
            not line
            or line.startswith("BYT;")
            or line.startswith(diskpath)
            or not re.match(r"^[1-9][0-9]*:", line)
        ):
            continue

        # Strip trailing ';' to avoid empty last field issues
        if line.endswith(";"):
            line = line[:-1]

        fields = line.split(":")
        if len(fields) < 4:
            continue

        start = mib_to_int(fields[1].strip())
        end = mib_to_int(fields[2].strip())

        if parted_is_free_row(fields):
            # if free space doesn't start at MIB boundaries it couldn't be the right free space after the partition where we search for the free space after
            if "." in fields[1].strip():
                continue
            logging.info(
                f"Adding partition entry kind: free, start: {start}, end: {end}"
            )
            entries.append({"kind": "free", "start": start, "end": end})
            continue

        # if end is not on MiB boundaries and a float we don't use this partition
        if "." in fields[2].strip():
            continue

        # Partition row: first column is partition number here
        try:
            n = int(fields[0].strip())
        except Exception:
            logging.error(f"cannot parse partition number from line: {line!r}")
            sys.exit(1)
        logging.info(f"Adding partition entry kind: part, start: {start}, end: {end}")
        entries.append({"kind": "part", "n": n, "start": start, "end": end})

    # Entries are already in physical order because parted prints them that way.
    logging.info(f"Partition entries: {json.dumps(entries, indent=2)}")
    return entries


def get_start_mib_after_partnumber(
    diskpath: str,
    required_mib: int,
    partnumber: int,
    dryrun: bool = False,
) -> tuple[int, int]:

    min_tail_free_mib = 1
    entries = read_parted_entries(diskpath, dryrun=dryrun)
    if dryrun:
        # FIXME
        return (0, 0)

    # Locate partnumber
    p = None
    idx_p = None
    for i, e in enumerate(entries):
        if e["kind"] == "part" and e["n"] == partnumber:
            idx_p = i
            p = e
            break
    if p is None:
        logging.error(
            f"{diskpath}: partition {partnumber} not found or ignored (likely fractional END in parted output)"
        )
        sys.exit(1)

    # search for partitions that physically come after partnumber on disk (parted output lists parts sorted by physical position not part number)
    later_parts = [e for e in entries[idx_p + 1 :] if e["kind"] == "part"]
    if later_parts:
        later_desc = ", ".join(
            f"p{e['n']}@{e['start']}-{e['end']}MiB" for e in later_parts
        )
        logging.error(
            f"{diskpath}: partitions exist after p{partnumber}: {later_desc}. Refusing."
        )
        sys.exit(1)

    start_mib = int(p["end"])

    # Find a free region that starts at start_mib after partnumber
    free_after = None
    for e in entries[idx_p + 1 :]:
        if e["kind"] != "free":
            continue
        # cover start_mib
        if e["start"] == start_mib and e["end"] > start_mib:
            free_after = e
            break
        # allow exact boundary (start==end is useless but we handle it below, can be free space less than 1MiB)
        if e["start"] == start_mib and e["end"] == start_mib:
            free_after = e
            break

    if free_after is None:
        logging.error(
            f"{diskpath}: no free region immediately after/covering start_mib={start_mib}MiB following p{partnumber}."
        )
        sys.exit(1)

    avail_mib = int(free_after["end"]) - start_mib

    if avail_mib < min_tail_free_mib:
        logging.error(
            f"{diskpath}: free space after p{partnumber} too small: {avail_mib}MiB < {min_tail_free_mib}MiB."
        )
        sys.exit(1)

    if avail_mib < required_mib:
        logging.error(
            f"{diskpath}: insufficient free space after p{partnumber}: need={required_mib}MiB, available={avail_mib}MiB (from {start_mib}MiB to {free_after['end']}MiB)."
        )
        sys.exit(1)

    logging.info(
        f"Free space after partition {partnumber} begins at the end of partition {partnumber} at {int(start_mib)}MiB which is the start of free space at {int(free_after['start'])}MiB"
    )
    logging.info(
        f"Free space after partition {partnumber} ends at {int(free_after['end'])}MiB"
    )
    logging.info(
        f"Free space after partition {partnumber} has therefore a size {avail_mib}MiB"
    )
    return (start_mib, avail_mib)


def do_cryptsetup(partition: str, cryptpw: str, dryrun: bool = False) -> str | None:

    password = (cryptpw + "\n").encode("utf-8")
    subprocess_run_wrapper(
        cmd=(
            "cryptsetup luksFormat "
            "--type luks2 "
            "--batch-mode "
            "-c aes-xts-plain64 "
            "-s 512 "
            "-h sha512 "
            "-i 5000 "
            "--use-random "
            "--align-payload 2048 "
            f"{shlex.quote(partition)}"
        ),
        dryrun=dryrun,
        input=password,
        check=True,
    )

    do_device_settle(dryrun=dryrun)

    result = subprocess_run_wrapper(
        cmd=f"blkid -s UUID -o value {shlex.quote(partition)}",
        dryrun=dryrun,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True,
    )

    if dryrun or result is None:
        return None

    uuid = result.stdout.strip()

    subprocess_run_wrapper(
        cmd=(
            "cryptsetup open "
            "--type luks2 "
            "--batch-mode "
            "--allow-discards "
            f"{shlex.quote(partition)} "
            f"luks-{shlex.quote(uuid)}"
        ),
        dryrun=dryrun,
        input=password,
        check=True,
    )

    do_device_settle(dryrun=dryrun)

    logging.info(
        f"Created LUKS device on {partition} with UUID {uuid} and opened it as luks-{uuid}"
    )

    return uuid


def do_mkfs(part: str, parttype: str, dryrun: bool = False) -> str:
    match parttype:
        case "EFI":
            subprocess_run_wrapper(
                cmd=f"mkfs.vfat -F 32 {shlex.quote(part)}", dryrun=dryrun
            )
        case "btrfs":
            subprocess_run_wrapper(
                cmd=f"mkfs.btrfs -d single -m dup {shlex.quote(part)}", dryrun=dryrun
            )
        case _:
            logging.error(f"Unsupported parttype {parttype} - exiting")
            sys.exit(1)

    result = subprocess_run_wrapper(
        cmd=f"blkid -s UUID -o value {shlex.quote(part)}",
        dryrun=dryrun,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        check=True,
    )

    if dryrun or result is None:
        return None

    uuid = result.stdout.strip()

    logging.info(f"Formatted partition {part} as {parttype} with UUID {uuid}")

    return uuid


def do_btrfs_subvols(part: str, subvolumes: list, dryrun: bool = False):
    mountpoint = "/btrfs"
    logging.info(f"Mounting {part} at {mountpoint}")
    os.makedirs(mountpoint, exist_ok=True)
    subprocess_run_wrapper(
        cmd=f"mount -o rw,subvolid=5,compress=zstd:1,discard=async {shlex.quote(part)} {shlex.quote(mountpoint)}",
        dryrun=dryrun,
    )
    try:
        for sub in subvolumes:
            path = os.path.join(mountpoint, sub)
            logging.info(f"Creating btrfs subvolume {path}")
            subprocess_run_wrapper(
                cmd=f"btrfs subvolume create {shlex.quote(path)}", dryrun=dryrun
            )
    finally:
        logging.info(f"Unmounting {mountpoint}")
        subprocess_run_wrapper(cmd=f"umount {shlex.quote(mountpoint)}", dryrun=dryrun)
        os.rmdir(mountpoint)


def do_write_disk_var_sh(esppart: str, bootpart: str, rootpart: str, bootdev: str):
    disk_var_sh = os.path.join(os.environ["LOGDIR"], "disk_var.sh")
    with open(disk_var_sh, "w") as f:
        f.write(f'ESP_DEVICE="{esppart}"\n')
        f.write(f'BOOT_PARTITION="{bootpart}"\n')
        f.write(f'ROOT_PARTITION="{rootpart}"\n')
        f.write('SWAPLIST=""\n')
        f.write(f'BOOT_DEVICE="{bootdev}"\n')
        f.write(f'PHYSICAL_BOOT_DEVICES="{bootdev}"\n')


def do_write_crypttab(crypt_uuids: list):
    crypttab = os.path.join(os.environ["LOGDIR"], "crypttab")
    with open(crypttab, "w") as f:
        for crypt_uuid in crypt_uuids:
            f.write(f"luks-{crypt_uuid} UUID={crypt_uuid} none luks,discard\n")


def do_write_fstab(efi_uuid: str, boot_uuid: str, root_uuid: str):
    fstab = os.path.join(os.environ["LOGDIR"], "fstab")
    with open(fstab, "w") as f:
        f.write(
            f"UUID={root_uuid} /         btrfs   rw,subvol=os,compress=zstd:1,x-systemd.device-timeout=0,discard=async 0 1\n"
        )
        f.write(
            f"UUID={boot_uuid} /boot    btrfs   rw,subvol=boot,compress=zstd:1,x-systemd.device-timeout=0,discard=async  0 2\n"
        )
        f.write(f"UUID={efi_uuid} /boot/efi vfat    rw,discard             0 2\n")


def get_uuid_of_existing_fs(part: str, dryrun: bool = False) -> str:
    # Use blkid to read UUID without touching filesystem
    cp = subprocess_run_wrapper(
        cmd=f"blkid -s UUID -o value {shlex.quote(part)}",
        dryrun=dryrun,
        shell=True,
        executable="/bin/bash",
        check=True,
        capture_output=True,
        text=True,
    )
    uuid = (cp.stdout or "").strip()
    logging.info(f"Partition {part} has following filesystem UUID: {uuid}")
    return uuid


def do_setup_storage(
    diskpath: str, diskinfo: dict, disklayout: dict, cryptpw: str, dryrun: bool = False
):
    esp_number = disklayout["esp"]["number"]
    boot_number = disklayout["boot"]["number"]
    root_number = disklayout["root"]["number"]

    crypt_root_uuid = do_cryptsetup(
        partition=f"{diskpath}-part{root_number}", cryptpw=cryptpw, dryrun=dryrun
    )

    if disklayout["esp"]["wipe"]:
        efi_uuid = do_mkfs(
            part=f"{diskpath}-part{esp_number}", parttype="EFI", dryrun=dryrun
        )
    else:
        efi_uuid = get_uuid_of_existing_fs(
            part=f"{diskpath}-part{esp_number}", dryrun=dryrun
        )

    boot_uuid = do_mkfs(
        part=f"{diskpath}-part{boot_number}", parttype="btrfs", dryrun=dryrun
    )
    root_uuid = do_mkfs(
        part=f"/dev/mapper/luks-{crypt_root_uuid}", parttype="btrfs", dryrun=dryrun
    )

    do_btrfs_subvols(
        part=f"{diskpath}-part{boot_number}", subvolumes=["boot"], dryrun=dryrun
    )
    do_btrfs_subvols(
        part=f"/dev/mapper/luks-{crypt_root_uuid}", subvolumes=["os"], dryrun=dryrun
    )

    do_write_disk_var_sh(
        esppart=f"{diskpath}-part{esp_number}",
        bootpart=f"{diskpath}-part{boot_number}",
        rootpart=f"/dev/mapper/luks-{crypt_root_uuid}",
        bootdev=f"{diskpath}",
    )

    do_write_crypttab(crypt_uuids=[crypt_root_uuid])

    do_write_fstab(efi_uuid=efi_uuid, boot_uuid=boot_uuid, root_uuid=root_uuid)


def main():
    dryrun = False
    logging.basicConfig(level=logging.INFO, format="[%(levelname)s] %(message)s")

    ks = os.path.isdir("/usr/share/anaconda")
    fai = os.path.isdir("/var/lib/fai")
    if ks and fai:
        logging.error("Found both Anaconda dir and FAI dir - can only be either or")
        sys.exit(1)

    disklayoutid = "{{disklayoutid}}"
    diskpath = "{{diskpath}}"
    startpartition = {{startpartition}}
    rootsizemib = {{rootsizemib}}
    cryptpw = False

    btrfsrootlabel = "fedora_fedora"
    btrfsbootlabel = "fedora_boot"

    logging.info(f"disklayoutid: {shlex.quote(str(disklayoutid))}")
    logging.info(f"diskpath: {shlex.quote(str(diskpath))}")
    logging.info(f"startpartition: {int(startpartition)}")
    logging.info(f"rootsizemib: {int(rootsizemib)}")
    logging.info("cryptpw: hidden")

    rootsizemibmin = int(10240)

    if rootsizemib < rootsizemibmin:
        logging.error(
            f"rootsizemib {rootsizemib} < rootsizemibmin {rootsizemibmin} - exiting"
        )
        sys.exit(1)

    disklayouts = {
        "singleos": {
            "esp": {"number": 1, "wipe": True, "sizemib": 2047},
            "boot": {"number": 2, "wipe": True, "sizemib": 2048},
            "root": {"number": 3, "wipe": True, "sizemib": rootsizemib},
        },
        "multios": {
            "esp": {"number": 1, "wipe": False, "sizemib": 2047},
            "boot": {"number": int(startpartition), "wipe": True, "sizemib": 2048},
            "root": {
                "number": int(startpartition) + 1,
                "wipe": True,
                "sizemib": rootsizemib,
            },
        },
    }

    logging.info(f"disklayouts:\n{json.dumps(disklayouts, indent=2)}")

    disklayout = disklayouts.get(disklayoutid, False)
    logging.info(f"disklayout:\n{json.dumps(disklayout, indent=2)}")
    if not disklayout:
        logging.error(f"Couldn't get disklayout {disklayoutid}")
        sys.exit(1)

    diskinfo = get_diskinfo(diskpath=diskpath, dryrun=dryrun)

    if not diskinfo:
        logging.error(f"Couldn't get diskinfo {diskpath}")
        sys.exit(1)

    match disklayoutid:
        case "singleos":
            should_partition = check_should_partition(
                diskpath=diskpath, diskinfo=diskinfo
            )

            if should_partition:
                do_partition(diskpath=diskpath, disklayout=disklayout, dryrun=dryrun)
            else:
                logging.info("Partitioning skipped.")

        case "multios":
            if disklayout["boot"]["number"] < 1:
                logging.error(
                    f"startpartition/number of boot partition {disklayout['boot']['number']} not set correctly - exiting"
                )
                sys.exit(1)

            # check if partition all partition exist, that have a number smaller that boot partition number (example: 1,2,3,4 if boot partition number is 5) if not: exit with error

            parts_by_no: dict[int, dict] = {}

            diskparts = diskinfo.get("children")
            for p in diskparts:
                partnumber = p.get("partno") or p.get("partn")
                if partnumber:
                    parts_by_no[int(partnumber)] = p
            logging.info(f"parts_by_no:\n{json.dumps(parts_by_no, indent=2)}")

            missing = [
                n
                for n in range(1, disklayout["boot"]["number"])
                if n not in parts_by_no
            ]
            logging.info(f"missing: {missing}")
            if missing:
                logging.error(
                    f"{diskpath}: expected partitions 1-{disklayout['boot']['number'] - 1} to exist, missing: {missing}"
                )
                sys.exit(1)

            # check if partition 1 is a valid EFI partition, if not: exit with error
            ESP_GPT_GUID = "c12a7328-f81f-11d2-ba4b-00a0c93ec93b"
            p1 = parts_by_no[1]
            p1_fstype = (p1.get("fstype") or "").lower()
            p1_parttype = (p1.get("parttype") or "").lower()
            p1_typename = (p1.get("parttypename") or "").lower()
            p1_flags = (p1.get("partflags") or "").lower()

            logging.info(f"p1_fstype: {p1_fstype}")
            logging.info(f"p1_parttype: {p1_parttype}")
            logging.info(f"p1_typename: {p1_typename}")
            logging.info(f"p1_flags: {p1_flags}")

            looks_like_esp = (
                (p1_parttype == ESP_GPT_GUID)
                or ("efi system" in p1_typename)
                or ("esp" in p1_flags)
                or ("boot" in p1_flags)
                or (p1_fstype in ("vfat", "fat", "fat32"))
            )
            if not looks_like_esp:
                logging.error(
                    f"{diskpath}: partition 1 does not look like an EFI System Partition. "
                    f"fstype={p1.get('fstype')} parttype={p1.get('parttype')} "
                    f"typename={p1.get('parttypename')} flags={p1.get('partflags')}"
                )
                sys.exit(1)
            logging.info("p1 looks like a EFI partition - continuing")

            # check if partitions other than larger or equal than boot partition number exist,
            extras = sorted(
                n
                for n in parts_by_no.keys()
                if n not in range(1, disklayout["boot"]["number"])
            )
            logging.info(f"extras: {extras}")
            # - if yes: do not partition at all, but check if boot partition number  and root partition number exist, if not: exit with error
            if extras:
                if (
                    disklayout["boot"]["number"] not in parts_by_no
                    or disklayout["root"]["number"] not in parts_by_no
                ):
                    logging.error(
                        f"{diskpath}: found extra partitions beyond 1-{disklayout['boot']['number'] - 1} ({extras}) "
                        f"but required Linux partitions for boot number {disklayout['boot']['number']} and for root number {disklayout['root']['number']} are not both present."
                    )
                    sys.exit(1)
                logging.info(
                    f"{diskpath}: partitions beyond 1-{disklayout['boot']['number'] - 1} already exist ({extras}); will not create new partitions."
                )

            # - if no:  create boot and root part at beginning of free space which must begin directly after last part before boot and no other parts until the end of disk
            else:
                required_mib = int(disklayout["boot"]["sizemib"]) + int(
                    disklayout["root"]["sizemib"]
                )
                logging.info(f"required_mib: {required_mib}")
                start_mib, avail_mib = get_start_mib_after_partnumber(
                    diskpath=diskpath,
                    required_mib=required_mib,
                    partnumber=disklayout["boot"]["number"] - 1,
                    dryrun=dryrun,
                )
                logging.info(f"start_mib: {start_mib}")
                logging.info(f"avail_mib: {avail_mib}")
                do_add_partitions(
                    diskpath=diskpath,
                    disklayout=disklayout,
                    start_mib=start_mib,
                    dryrun=dryrun,
                )

        case _:
            logging.error(f"Unknown disklayoutid {disklayoutid} - exiting")
            sys.exit(1)

    if diskinfo.get("children"):
        # wiped = do_wipeparts(
        do_wipeparts(
            diskpath=diskpath, diskinfo=diskinfo, disklayout=disklayout, dryrun=dryrun
        )

    if ks:
        write_ks_snippets(
            diskpath=diskpath,
            disklayout=disklayout,
            btrfsbootlabel=btrfsbootlabel,
            btrfsrootlabel=btrfsrootlabel,
        )
    elif fai:
        if not isinstance(cryptpw, str) or cryptpw == "":
            logging.error(
                "cryptpw is not set, usually it must be set in hostconf of faibuilder which ensures an env var CRYPTPW is set in fai"
            )
            sys.exit(1)

        do_setup_storage(
            diskpath,
            diskinfo=diskinfo,
            disklayout=disklayout,
            cryptpw=cryptpw,
            dryrun=dryrun,
        )
        subprocess_run_wrapper(
            cmd="skiptask partition",
            dryrun=dryrun,
            shell=True,
            executable="/bin/bash",
            check=True,
        )


if __name__ == "__main__":
    main()

%end

%include /tmp/partitions.ks

# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'
# System language
lang en_US.UTF-8

%packages
@^workstation-product-environment

%end

# System authorization information
authselect enable-feature with-fingerprint

# Run the Setup Agent on first boot
firstboot --disable

# System timezone
timezone Europe/Vienna --utc

#Root password
rootpw --lock
user --groups=wheel --name={{username}} --password={{userpw}} --iscrypted --uid=1000 --gid=1000

#FIXME disable location services configured in gnome-firstboot

%post --erroronfail --nochroot

DISK=$(cat /tmp/disk-id)
BOOT_NUMBER=$(cat /tmp/boot-number)
parted --script "${DISK}" set ${BOOT_NUMBER} bls_boot on
udevadm trigger && sleep 5 && udevadm settle && sleep 5

mkdir -p /mnt/sysroot/var/log/anaconda
cp /tmp/partitions.ks /mnt/sysroot/var/log/anaconda/

%end

%post --erroronfail

chage -d 0 hoo || true

systemctl enable sshd.service

%end
